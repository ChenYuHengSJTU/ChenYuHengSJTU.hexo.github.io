<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuheng Chen Blog</title>
  
  
  <link href="https://chenyuhengsjtu.github.io/atom.xml" rel="self"/>
  
  <link href="https://chenyuhengsjtu.github.io/"/>
  <updated>2023-07-12T00:48:40.297Z</updated>
  <id>https://chenyuhengsjtu.github.io/</id>
  
  <author>
    <name>ChenYuHeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim.html</title>
    <link href="https://chenyuhengsjtu.github.io/2023/07/12/Vim-html/"/>
    <id>https://chenyuhengsjtu.github.io/2023/07/12/Vim-html/</id>
    <published>2023-07-12T00:48:40.000Z</published>
    <updated>2023-07-12T00:48:40.297Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="https://chenyuhengsjtu.github.io/2023/07/12/Vim/"/>
    <id>https://chenyuhengsjtu.github.io/2023/07/12/Vim/</id>
    <published>2023-07-12T00:48:22.000Z</published>
    <updated>2023-07-12T00:48:40.373Z</updated>
    
    <content type="html"><![CDATA[<html lang="en">    <head>        <meta charset="utf-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">        <title>Vim</title>        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/dist/reset.css">        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/dist/reveal.css">        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/dist/theme/white.css">        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.css">        <!-- Theme used for syntax highlighted code -->        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/plugin/highlight/monokai.css">    </head>    <style>        section {            font-size: 30px;        }        p {            text-align: left;        }        ul {            text-align: left;        }        li {            text-align: left;        }    </style>    <body>        <div class="reveal">            <div class="slides"><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="vim的几种模式">Vim的几种模式</h2></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="启动vim">启动Vim</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>vim + file ： 从文件末尾开始</li><li>vim +num file: 从第num行开始</li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="文档操作">文档操作</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>:x – 保存并退出</li><li>:saveas newfilename – 另存为</li><li>:f filename – 改变编辑的文件名，这时再保存相当于另存为</li><li>:Sex – 水平分割一个窗口，浏览文件系统；</li><li>:Vex – 垂直分割一个窗口，浏览文件系统；</li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="光标移动">光标移动</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="基本移动">基本移动</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>normal 模式下：<ul><li>w: 将光标移动到下一个单词的开头</li><li>b: 将光标移动到前一个单词的开头</li><li>e: 将光标移动到下一个单词的词末</li><li>E: 移动到单词的结尾(忽略标点符号)</li><li>ge: 将光标移动到上一个单词的词末</li><li><mark>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</mark></li><li>0: 移动到行首。</li><li>g0: 移到光标所在屏幕行行首</li><li>$: 移动到行尾。</li><li>g$: 移动光标所在屏幕行行尾。</li><li>n|: 把光标移到递n列上。</li><li>nG: 到文件第n行。</li></ul></li></ul><hr><ul><li><ul><li>:n&lt; cr &gt; 移动到第n行。</li><li>:$&lt; cr &gt; 移动到最后一行。</li><li>H: 把光标移到屏幕最顶端一行。</li><li>M: 把光标移到屏幕中间一行。</li><li>L: 把光标移到屏幕最底端一行。</li><li>gg: 到文件头部。</li><li>G: 到文件尾部。</li><li>(：移到当前句子的开头</li><li>): 移到下一个句子的开头</li><li>{: 移到当前一段的开头</li><li>}：移到下一段的开头</li><li>[ [ : 移到当前这一节的开头</li><li>]]: 移到下一节的开头</li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="翻屏">翻屏</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>ctrl+f: 下翻一屏。</li><li>ctrl+b: 上翻一屏。</li><li>ctrl+d: 下翻半屏。</li><li>ctrl+u: 上翻半屏。</li><li>ctrl+e: 向下滚动一行。</li><li>ctrl+y: 向上滚动一行。</li><li>n%: 到文件n%的位置。</li><li>zz: 将当前行移动到屏幕中央。</li><li>zt: 将当前行移动到屏幕顶端。</li><li>zb: 将当前行移动到屏幕底端</li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="插入文本">插入文本</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="基本插入">基本插入</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 <mark>这在插入分割线时非常有用，如30i+&lt; esc &gt;就插入了36个+组成的分割线。</mark></li><li>I: 在当前行第一个非空字符前插入；</li><li>gI: 在当前行第一列插入；</li><li>a: 在光标后插入；</li><li>A: 在当前行最后插入；</li><li>o: 在下面新建一行插入；</li><li>O: 在上面新建一行插入；</li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="改写插入">改写插入</h5></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="剪切复制和寄存器">剪切复制和寄存器</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="剪切和复制粘贴">剪切和复制、粘贴</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>[ n ]x: 剪切光标右边n个字符，相当于d[n]l。</li><li>[ n ]X: 剪切光标左边n个字符，相当于d[n]h。</li><li>y: 复制在可视模式下选中的文本。</li><li>yy or Y: 复制整行文本。</li><li>y[n]w: 复制一(n)个词。</li><li>y[n]l: 复制光标右边1(n)个字符。</li><li>y[n]h: 复制光标左边1(n)个字符。</li><li>==y$: 从光标当前位置复制到行尾。</li><li>==y0: 从光标当前位置复制到行首。</li><li>:m,ny&lt; cr &gt; 复制m行到n行的内容。</li><li>==y1G或ygg: 复制光标以上的所有行。</li><li>==yG: 复制光标以下的所有行。</li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li><li>==d: 删除（剪切）在可视模式下选中的文本。</li><li>==d$ or D: 删除（剪切）当前位置到行尾的内容。</li><li>d[n]w: 删除（剪切）1(n)个单词</li><li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li><li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li><li>d0: 删除（剪切当前位置到行首的内容</li><li>[n ]dd: 删除（剪切）1(n)行。</li><li>:m,nd&lt;&gt; 剪切m行到n行的内容。</li><li>d1G或dgg: 剪切光标以上的所有行。</li><li>dG: 剪切光标以下的所有行。</li><li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li>d/f&lt;&gt;：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</li><li>p: 在光标之后粘贴。</li><li>P: 在光标之前粘贴。</li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="文本对象">文本对象</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>aw：一个词</li><li>as：一句。</li><li>ap：一段。</li><li>ab：一块（包含在圆括号中的）</li><li>==y, d, c, v都可以跟文本对象。</li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="查找与替换">查找与替换</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="查找">查找</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>/something: 在后面的文本中查找something。</li><li>?something: 在前面的文本中查找something。</li><li>/pattern/+number: 将光标停在包含pattern的行后面第number行上。</li><li>/pattern/-number: 将光标停在包含pattern的行前面第number行上。</li><li>n: 向后查找下一个。</li><li>N: 向前查找下一个。</li><li>可以用grep或vimgrep查找一个模式都在哪些地方出现过，其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。用法为： :vim[ grep ]/pattern/[g] [j] files</li><li>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</li><li>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</li><li>vimgrep前面可以加数字限定搜索结果的上限，如:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。</li><li>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：:vim/^d{1,}./ %然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，就更像个目录了。</li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="替换">替换</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>:s/old/new - 用new替换当前行第一个old。</li><li>:s/old/new/g - 用new替换当前行所有的old。</li><li>:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。</li><li>:%s/old/new/g - 用new替换文件中所有的old。</li><li>:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。</li><li>:%s/ $ /xxx/g - 在每一行的行尾插入xxx，$表示行尾。</li><li>所有替换命令末尾加上c，每个替换都将需要用户确认。</li><li>关于range的规定为：<ul><li>如果不指定range，则表示当前行。</li><li>m,n: 从m行到n行。</li><li>0: 最开始一行（可能是这样）。</li><li>$: 最后一行</li><li>. : 当前行</li><li>%: 所有行</li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="正则表达式">正则表达式</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>:help pattern得到更多帮助。</li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="排版">排版</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="基本排版">基本排版</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li><p>&lt;&lt; 向左缩进一个shiftwidth</p></li><li><p>&gt;&gt;向右缩进一个shiftwidth</p></li><li><p>:ce(nter) 本行文字居中</p></li><li><p>:le(ft) 本行文字靠左</p></li><li><p>:ri(ght) 本行文字靠右</p></li><li><p>gq 对选中的文字重排，即对过长的文字进行断行</p></li><li><p>gqq 重排当前行</p></li><li><p>gqnq 重排n行</p></li><li><p>gqap 重排当前段</p></li><li><p>gqnap 重排n段</p></li><li><p>gqnj 重排当前行和下面n行</p></li><li><p>gqQ 重排当前段对文章末尾</p></li><li><p>J 拼接当前行和下一行</p></li><li><p>gJ 同 J ，不过合并后不留空格。</p></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="拼写检查">拼写检查</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>:set spell－开启拼写检查功能</li><li>:set nospell－关闭拼写检查功能</li><li>]s－移到下一个拼写错误的单词</li><li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li><li>z=－显示一个有关拼写错误单词的列表，可从中选择</li><li>zg－告诉拼写检查器该单词是拼写正确的</li><li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h5 id="统计字数">统计字数</h5></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</li></ul></section></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_07.png" data-background-size="cover" data-background-repeat="no-repeat"></section>            </div>        </div>        <script src="https://chenyuhengsjtu.github.io/GitPages/dist/reveal.js"></script>        <script src="https://chenyuhengsjtu.github.io/GitPages/plugin/notes/notes.js"></script>        <script src="https://chenyuhengsjtu.github.io/GitPages/plugin/markdown/markdown.js"></script>        <script src="https://chenyuhengsjtu.github.io/GitPages/plugin/highlight/highlight.js"></script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>        <script>            // More info about initialization & config:            // - https://revealjs.com/initialization/            // - https://revealjs.com/config/            Reveal.initialize({                hash: true,                // Learn about plugins: https://revealjs.com/plugins/                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]            });        </script>        <script type="text/x-mathjax-config">            MathJax.Hub.Config({            tex2jax: {                inlineMath: [['$','$'], ['\(','\)']]            }            });        </script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-clike.min.js"></script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-c.min.js"></script>    </body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, max</summary>
      
    
    
    
    <category term="Blog" scheme="https://chenyuhengsjtu.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>Practical_Vim</title>
    <link href="https://chenyuhengsjtu.github.io/2023/07/12/Practical_Vim/"/>
    <id>https://chenyuhengsjtu.github.io/2023/07/12/Practical_Vim/</id>
    <published>2023-07-11T16:28:25.000Z</published>
    <updated>2023-07-11T16:28:25.845Z</updated>
    
    <content type="html"><![CDATA[<html lang="en">    <head>        <meta charset="utf-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">        <title>Practical_Vim</title>        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/dist/reset.css">        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/dist/reveal.css">        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/dist/theme/white.css">        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.css">        <!-- Theme used for syntax highlighted code -->        <link rel="stylesheet" href="https://chenyuhengsjtu.github.io/GitPages/plugin/highlight/monokai.css">    </head>    <style>        section {            font-size: 30px;        }        p {            text-align: left;        }        ul {            text-align: left;        }        li {            text-align: left;        }    </style>    <body>        <div class="reveal">            <div class="slides"><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="vim-解决问题的方式">Vim 解决问题的方式</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>结识.命令<ul><li>规划按键操作</li><li>一次按键移动，一次按键执行</li></ul></li><li>不要自我重复<ul><li>复合命令<ul><li><table><thead><tr class="header"><th>复合命令</th><th>等效命令</th></tr></thead><tbody><tr class="odd"><td>C</td><td>c$</td></tr><tr class="even"><td>s</td><td>cl</td></tr><tr class="odd"><td>S</td><td>^c</td></tr><tr class="even"><td>I</td><td>^i</td></tr><tr class="odd"><td>A</td><td>$a</td></tr><tr class="even"><td>o</td><td>A<CR></CR></td></tr><tr class="odd"><td>O</td><td>ko</td></tr></tbody></table></li></ul></li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>以退为进</li><li>执行，重复，回退<ul><li><table><thead><tr class="header"><th>操作</th><th>重复</th><th>回退</th></tr></thead><tbody><tr class="odd"><td>edit</td><td>.</td><td>u</td></tr><tr class="even"><td>f/t{char}</td><td>;</td><td>,</td></tr><tr class="odd"><td>F/T{char}</td><td>;</td><td>,</td></tr><tr class="even"><td>/pattern<CR></CR></td><td>n</td><td>N</td></tr><tr class="odd"><td>?pattern<CR></CR></td><td>n</td><td>N</td></tr><tr class="even"><td>: s</td><td>&amp;</td><td>u</td></tr><tr class="odd"><td>qx{changes}q</td><td><span class="citation" data-cites="x">@x</span></td><td>u</td></tr></tbody></table></li></ul></li><li>查找并手动替换<ul><li>* 会查找当前光标下的单词</li></ul></li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="普通模式">普通模式</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>把撤销单元切成块<ul><li>根据思考的提顿来切分</li><li>up down left right会在insert模式下额外切分</li></ul></li><li>构造可重复的修改<ul><li>使 . 发挥出最大的威力</li></ul></li><li>用次数做简单的算数运算<ul><li>注意数字的格式</li></ul></li><li>能够重复(.)就别用次数<ul><li>使.和u命令都有更细的粒度</li><li><strong><code>执行，重复，回退</code></strong></li></ul></li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="插入模式">插入模式</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>在插入模式中及时修正错误<ul><li>&lt;C - h&gt; 回退</li><li>&lt;C - w&gt; 删除前一个单词</li><li>&lt;C - u&gt; 删除至行首</li></ul></li><li>返回普通模式<ul><li>&lt;C - [&gt;</li><li>&lt;C - o&gt; 插入-普通模式<ul><li>可以执行一次普通模式的指令</li></ul></li></ul></li><li>不离开插入模式，粘贴寄存器中的文本<ul><li>&lt;C - r&gt;{register}</li></ul></li><li>16 随时随地做运算</li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>用字符编码插入非常用字符<ul><li>&lt;C - v&gt;{123}</li><li>&lt;C - v&gt;u{1234}</li><li>&lt;C - v&gt;{nondigit}</li><li>&lt;C - k&gt;{char1}{char2}<ul><li>插入二合字母表示的字符</li></ul></li></ul></li><li>用替换模式替换已有文本<ul><li>R</li><li>r – 单个字符</li></ul></li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="可视模式">可视模式</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><p>注意可以使用如r等命令对行，块进行操作，会作用在每一个字符上</p><ul><li>选择高亮区域<ul><li><table><thead><tr class="header"><th>命令</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>v</td><td>字符</td></tr><tr class="even"><td>V</td><td>行</td></tr><tr class="odd"><td>&lt;C-v&gt;</td><td>块</td></tr><tr class="even"><td>gv</td><td>重选</td></tr><tr class="odd"><td>o</td><td>切换高亮选区的活动端</td></tr></tbody></table></li><li>这些指令可以用于在不同模式下切换</li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>重复执行面向行的可视命令<ul><li>. 选择的文本数量和上次相同</li></ul></li><li>只要可能，最好使用操作符命令，而不是可视命令<ul><li>可是命令的.可能会产生异常行为</li><li>vit，viw</li><li>可视模式下，U -&gt; gU</li></ul></li><li>用面向列块的可视模式编辑表格数据<ul><li>以列为单位工作</li></ul></li><li>修改列文本<ul><li>用列块可视模式可以同时往若干行中插入文本</li></ul></li><li>在长短不一的高亮块后添加文本<ul><li>使用$</li><li>注意，i，a不能使用，要用I，A代替</li><li>按下&lt;ESC&gt;后会同步更改</li></ul></li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="命令行模式">命令行模式</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>结识命令行模式<ul><li>：，/,&lt;C-r&gt;=</li><li>&lt;C-r&gt;{register}插入寄存器内容</li><li>操作缓冲区文本的Ex命令 – 可以无需移动光标进行修改</li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><table><thead><tr class="header"><th>命令</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>[range]delete [x]</td><td>删除行到寄存器x</td></tr><tr class="even"><td>[range]yank [x]</td><td>复制</td></tr><tr class="odd"><td>[line]put [x]</td><td>指定行后粘贴寄存器x的内容</td></tr><tr class="even"><td>[range]copy {address}</td><td>将指定范围内的行拷贝到{address}所指定的行之下</td></tr><tr class="odd"><td>[range]move {address}</td><td>移动</td></tr><tr class="even"><td>[range]join</td><td>连接指定范围内的行</td></tr><tr class="odd"><td>[range]normal {commands}</td><td>对指定范围的每一行执行普通模式命令</td></tr><tr class="even"><td>[range]substitute/{pattern}/[string]/[flags]</td><td></td></tr><tr class="odd"><td>[range]global/{pattern}/[cmd]</td><td>对指定范围内匹配的行执行cmd</td></tr></tbody></table></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>在一行或多个连续行上执行命令<ul><li><table><thead><tr class="header"><th>符号</th><th>地址</th></tr></thead><tbody><tr class="odd"><td>1</td><td>第一行</td></tr><tr class="even"><td>$</td><td>最后一行</td></tr><tr class="odd"><td>0</td><td>虚拟行，位于1上方</td></tr><tr class="even"><td>.</td><td>光标所在行</td></tr><tr class="odd"><td>’m</td><td>包含位置标记m的行</td></tr><tr class="even"><td>’&lt;</td><td>高亮选区的起始行</td></tr><tr class="odd"><td>’&gt;</td><td>结束行</td></tr><tr class="even"><td>%</td><td>所有行</td></tr></tbody></table></li><li>可以使用高亮区域表示范围，使用模式指定范围，以及用偏移对地址进行修正</li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>使用’:t’和’:m’命令复制和移动行<ul><li><table><thead><tr class="header"><th>命令</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>:6t.</td><td>line6 -&gt; curline</td></tr><tr class="even"><td>:t6</td><td>curline-&gt;below line6</td></tr><tr class="odd"><td>:t.</td><td>yyp</td></tr><tr class="even"><td>:t$</td><td></td></tr></tbody></table></li></ul></li><li><strong>在指定范围上执行普通模式命令</strong><ul><li>[range]normal [cmd]<ul><li>如对多行执行相同的操作，如添加注释等</li></ul></li></ul></li><li>重复上次的Ex命令<ul><li>@:</li><li>bn,bp</li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>自动补全Ex命令<ul><li><C-d>显示可用的补全列表</C-d></li><li><Tab> <S-Tab></S-Tab></Tab></li></ul></li><li>把当前单词插入到命令行<ul><li><C-r><C-w>:插入单词</C-w></C-r></li><li><C-r><C-a>:插入字串</C-a></C-r></li></ul></li><li>回溯历史命令<ul><li>set history=N</li></ul></li><li>结识命令行窗口<ul><li>q:</li><li><table><thead><tr class="header"><th>命令</th><th>动作</th></tr></thead><tbody><tr class="odd"><td>q/</td><td>查找历史命令窗口</td></tr><tr class="even"><td>q:</td><td>打开Ex命令窗口</td></tr><tr class="odd"><td>&lt;C-f&gt;</td><td>命令行模式到命令行窗口</td></tr></tbody></table></li></ul></li></ul></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>运行Shell命令<ul><li>!cmd</li><li>% 当前文件名称</li><li>:te:交互式shell会话 – exit退出</li><li>:read !{cmd}把命令的标准输出重定向到缓冲区</li><li>write !{cmd} 把缓冲区内容传给外部的sh命令作为标准输入</li><li>write! {cmd} 覆盖写入一个文件</li><li><strong>使用外部命令过滤缓冲区内容</strong><ul><li>[range]!{cmd}<ul><li>[range]write !{cmd}</li></ul></li><li>Vim对grep以及make有包装命令</li></ul></li></ul></li></ul></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="文件">文件</h2></section></section><section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_04.png" data-background-size="cover" data-background-repeat="no-repeat"><h2 id="管理多个文件">管理多个文件</h2></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_02.png" data-background-size="cover" data-background-repeat="no-repeat"><ul><li>用缓冲区列表管理打开的文件<ul><li>缓冲区：文件在内存中的映像</li><li>:ls<ul><li>:bprev,:bnext,bfirst,blast</li><li>:buffer N,:buffer {bufname}</li><li>:bdelete</li></ul></li></ul></li><li>用参数列表将缓冲区分组<ul><li>:args<ul><li>:args {arglist:通配符，文件名，shell命令结果}<ul><li>填充列表参数</li><li>可以使用Glob模式指定文件<ul><li>**不可递归，*可递归</li></ul></li><li>使用反引号指定文件:shell命令的输出作为args的参数</li></ul></li></ul></li><li>:argdo:执行命令</li><li>:next,:prev</li></ul></li></ul></section></section><section data-background-image="https://chenyuhengsjtu.github.io/SJTU/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80/1.%E7%99%BE%E5%BB%BF%E7%BA%A2-%E6%9D%8E%E4%B8%80_07.png" data-background-size="cover" data-background-repeat="no-repeat"></section>            </div>        </div>        <script src="https://chenyuhengsjtu.github.io/GitPages/dist/reveal.js"></script>        <script src="https://chenyuhengsjtu.github.io/GitPages/plugin/notes/notes.js"></script>        <script src="https://chenyuhengsjtu.github.io/GitPages/plugin/markdown/markdown.js"></script>        <script src="https://chenyuhengsjtu.github.io/GitPages/plugin/highlight/highlight.js"></script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>        <script>            // More info about initialization & config:            // - https://revealjs.com/initialization/            // - https://revealjs.com/config/            Reveal.initialize({                hash: true,                // Learn about plugins: https://revealjs.com/plugins/                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]            });        </script>        <script type="text/x-mathjax-config">            MathJax.Hub.Config({            tex2jax: {                inlineMath: [['$','$'], ['\(','\)']]            }            });        </script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-clike.min.js"></script>        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-c.min.js"></script>    </body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, max</summary>
      
    
    
    
    <category term="Blog" scheme="https://chenyuhengsjtu.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://chenyuhengsjtu.github.io/2023/07/12/test/"/>
    <id>https://chenyuhengsjtu.github.io/2023/07/12/test/</id>
    <published>2023-07-11T16:02:27.000Z</published>
    <updated>2023-07-11T16:03:41.434Z</updated>
    
    <content type="html"><![CDATA[<p>hello world</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hello world&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>About Myself</title>
    <link href="https://chenyuhengsjtu.github.io/index.html"/>
    <id>https://chenyuhengsjtu.github.io/index.html</id>
    <published>2023-05-15T05:34:44.835Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to MyBlog!</p><p>Wish my blog be of some help to you.</p><p>Have a nice journey!</p><img src="/index/SJTUlogo1.png" class title="This is an example image">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to MyBlog!&lt;/p&gt;
&lt;p&gt;Wish my blog be of some help to you.&lt;/p&gt;
&lt;p&gt;Have a nice journey!&lt;/p&gt;
&lt;img src=&quot;/index/SJTUlogo1.png&quot; class titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chenyuhengsjtu.github.io/2023/05/15/hello-world/"/>
    <id>https://chenyuhengsjtu.github.io/2023/05/15/hello-world/</id>
    <published>2023-05-15T05:26:59.746Z</published>
    <updated>2023-05-15T05:26:59.746Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MITOS_Lab02</title>
    <link href="https://chenyuhengsjtu.github.io/2023/03/07/MITOS-Lab02/"/>
    <id>https://chenyuhengsjtu.github.io/2023/03/07/MITOS-Lab02/</id>
    <published>2023-03-07T05:49:01.000Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MITOS-Lab02"><a href="#MITOS-Lab02" class="headerlink" title="MITOS_Lab02"></a>MITOS_Lab02</h1><p><strong>代码参考链接：<a href="https://github.com/ChenYuHengSJTU/MIT_OSLab/tree/syscall">ChenYuHengSJTU/MIT_OSLab at syscall (github.com)</a></strong></p><span id="more"></span><h2 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h2><hr><p><strong>TODO</strong></p><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p><p>We provide a <code>trace</code> user-level program that runs another program with tracing enabled (see <code>user/trace.c</code>). When you’re done, you should see output like this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">trace 32 grep hello README</span></span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">3: syscall read -&gt; 966</span><br><span class="line">3: syscall read -&gt; 70</span><br><span class="line">3: syscall read -&gt; 0</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">$ trace 2147483647 grep hello README</span></span><br><span class="line">4: syscall trace -&gt; 0</span><br><span class="line">4: syscall exec -&gt; 3</span><br><span class="line">4: syscall open -&gt; 3</span><br><span class="line">4: syscall read -&gt; 1023</span><br><span class="line">4: syscall read -&gt; 966</span><br><span class="line">4: syscall read -&gt; 70</span><br><span class="line">4: syscall read -&gt; 0</span><br><span class="line">4: syscall close -&gt; 0</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">$ grep hello README</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">$ trace 2 usertests forkforkfork</span></span><br><span class="line">usertests starting</span><br><span class="line">test forkforkfork: 407: syscall fork -&gt; 408</span><br><span class="line">408: syscall fork -&gt; 409</span><br><span class="line">409: syscall fork -&gt; 410</span><br><span class="line">410: syscall fork -&gt; 411</span><br><span class="line">409: syscall fork -&gt; 412</span><br><span class="line">410: syscall fork -&gt; 413</span><br><span class="line">409: syscall fork -&gt; 414</span><br><span class="line">411: syscall fork -&gt; 415</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> </span> </span><br></pre></td></tr></table></figure><p>In the first example above, trace invokes grep tracing just the read system call. The 32 is <code>1&lt;&lt;SYS_read</code>. In the second example, trace runs grep while tracing all system calls; the 2147583647 has all 31 low bits set. In the third example, the program isn’t traced, so no trace output is printed. In the fourth example, the fork system calls of all the descendants of the <code>forkforkfork</code> test in <code>usertests</code> are being traced. Your solution is correct if your program behaves as shown above (though the process IDs may be different).</p><p><strong>Hints</strong></p><ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li><li>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</li></ul><hr><h2 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h2><hr><p><strong>TODO</strong></p><p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p><p><strong>Hints</strong></p><ul><li><p>Add <code>$U/_sysinfotest</code> to UPROGS in Makefile</p></li><li><p>Run make qemu; <code>user/sysinfotest.c</code> will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() <code>in user/user.h</code> you need predeclare the existence of <code>struct sysinfo</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>;</span><br></pre></td></tr></table></figure><p>Once you fix the compilation issues, run <code>sysinfotest</code>; it will fail because you haven’t implemented the system call in the kernel yet.</p></li><li><p>sysinfo needs to copy a <code>struct sysinfo</code> back to user space; see <code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) and <code>filestat()</code> (<code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.</p></li><li><p>To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code></p></li><li><p>To collect the number of processes, add a function to <code>kernel/proc.c</code></p></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MITOS-Lab02&quot;&gt;&lt;a href=&quot;#MITOS-Lab02&quot; class=&quot;headerlink&quot; title=&quot;MITOS_Lab02&quot;&gt;&lt;/a&gt;MITOS_Lab02&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码参考链接：&lt;a href=&quot;https://github.com/ChenYuHengSJTU/MIT_OSLab/tree/syscall&quot;&gt;ChenYuHengSJTU/MIT_OSLab at syscall (github.com)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MITOS" scheme="https://chenyuhengsjtu.github.io/categories/MITOS/"/>
    
    
    <category term="Lab" scheme="https://chenyuhengsjtu.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>MITOS_Lab01</title>
    <link href="https://chenyuhengsjtu.github.io/2023/03/07/MITOS-Lab01/"/>
    <id>https://chenyuhengsjtu.github.io/2023/03/07/MITOS-Lab01/</id>
    <published>2023-03-07T03:49:14.000Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MITOS—Lab01—Xv6-and-Unix-utilities"><a href="#MITOS—Lab01—Xv6-and-Unix-utilities" class="headerlink" title="MITOS—Lab01—Xv6 and Unix utilities"></a>MITOS—Lab01—Xv6 and Unix utilities</h1><p><strong>代码参考链接：<a href="https://github.com/ChenYuHengSJTU/MIT_OSLab">ChenYuHengSJTU/MIT_OSLab (github.com)</a></strong></p><span id="more"></span><h2 id="Boot-xv6-easy"><a href="#Boot-xv6-easy" class="headerlink" title="Boot xv6 (easy)"></a>Boot xv6 (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">easy</a>)</h2><h2 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">easy</a>)</h2><hr><p><strong>TODO</strong></p><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p><p><strong>Hints</strong></p><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user/ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sleep:Missing arguments [Error]\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Do-not-forget"><a href="#Do-not-forget" class="headerlink" title="Do not forget"></a>Do not forget</h3><p>add <code>$U/_sleep\</code> to makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_pingpong\</span><br><span class="line">$U/_find\</span><br><span class="line">$U/_xargs\</span><br><span class="line">$U/_primes\</span><br></pre></td></tr></table></figure><h3 id="How-to-check"><a href="#How-to-check" class="headerlink" title="How to check"></a>How to check</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./grade-lab-util <span class="built_in">sleep</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make GRADEFLAGS=<span class="built_in">sleep</span> grade</span></span><br></pre></td></tr></table></figure><h2 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong (easy)"></a>pingpong (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">easy</a>)</h2><hr><p><strong>TODO</strong></p><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p><p><strong>Hints</strong></p><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有点别扭，可能不符合好的 routine，关于dup，pipe更高级的用法，可以看我的SJTUOS_LAB1--shell</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="comment">// int ptoc_p[2],ctop_p[2];</span></span><br><span class="line">    <span class="comment">// pipe(ptoc_p);</span></span><br><span class="line">    <span class="comment">// pipe(ctop_p);</span></span><br><span class="line">    <span class="type">char</span> byte[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    byte[<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// do not forget to close both the pipes in parent and child process</span></span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// read(ptoc_p[0],byte,1);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d: received ping\n&quot;,getpid());</span></span><br><span class="line">        <span class="comment">// write(ctop_p[1],byte,1);</span></span><br><span class="line">        read(p[<span class="number">0</span>],byte,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line">        write(p[<span class="number">1</span>],byte,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// write(ptoc_p[1],&quot;c&quot;,1);</span></span><br><span class="line">        <span class="comment">// wait((int*)(0));</span></span><br><span class="line">        <span class="comment">// read(ctop_p[0],byte,1);</span></span><br><span class="line">        write(p[<span class="number">1</span>],<span class="string">&quot;c&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span>*)(<span class="number">0</span>));</span><br><span class="line">        read(p[<span class="number">0</span>],byte,<span class="number">1</span>);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes-moderate-hard"><a href="#primes-moderate-hard" class="headerlink" title="primes (moderate)/(hard)"></a>primes (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">hard</a>)</h2><p>关于素数晒，可以看课程网站上的介绍，也可以bing或者google自行搜索</p><hr><p><strong>TODO</strong></p><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p><p><strong>Hints</strong></p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I/O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;primes:\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first_num = <span class="number">0</span>,num;</span><br><span class="line">    <span class="type">int</span> buffer[<span class="number">35</span>];</span><br><span class="line">    <span class="type">int</span> sz=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd[<span class="number">0</span>],&amp;first_num,<span class="keyword">sizeof</span>(<span class="type">int</span>)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,first_num);</span><br><span class="line">        <span class="keyword">while</span>(read(fd[<span class="number">0</span>],&amp;num,<span class="keyword">sizeof</span>(<span class="type">int</span>)))&#123;</span><br><span class="line">            <span class="comment">// if(num == 0) break;</span></span><br><span class="line">            <span class="keyword">if</span>(num % first_num != <span class="number">0</span>)&#123;</span><br><span class="line">                buffer[sz++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// It is important to create new pipe,otherwise the process will keep </span></span><br><span class="line">    <span class="comment">// writing and read what it has write.</span></span><br><span class="line">    pipe(fd);</span><br><span class="line">    write(fd[<span class="number">1</span>],buffer,sz * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        primes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// important to close fd in parent process</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line">    pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;++i)&#123;</span><br><span class="line">        write(fd[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i = 0;</span></span><br><span class="line">    <span class="comment">// write(fd[1],&amp;i,sizeof(int));</span></span><br><span class="line"></span><br><span class="line">    primes();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h2><p>写这篇博客的时候，因为课内课程需要（以及NJUOS-2023-Lab1），为了实现一个shell，自行学习了一下linux下遍历目录的方式（以后尽量出一片篇博客介绍，或者可以看SJTUOS课程大作业shell实现中对<code>cd</code>的特殊处理）</p><p>做这个实验的时候就是根据hints，照猫画虎</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bufsize 512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the char[] path should be defined in main as a char[512] ended with &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span>* path,<span class="type">char</span>* target)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>],*p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(path,<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;find: cannot open %s [1]\n&quot;</span>,path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;find: cannot stat %s [1]\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path)+<span class="built_in">strlen</span>(target)+<span class="number">1</span>&gt;Bufsize)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path is too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf,path);</span><br><span class="line">            p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">                <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(de.name,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span>) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,target)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>,path,target);</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p,de.name,DIRSIZ);</span><br><span class="line">                <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s [2]\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                find(buf,target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close() is so important</span></span><br><span class="line">    <span class="comment">// do not forget to close , otherwise some errors may occur</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error:Too few arguments for find\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span>)</span><br><span class="line">        find(<span class="string">&quot;.&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (<a href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h2><hr><p><strong>TODO</strong></p><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p><p>The following example illustrates xarg’s behavior:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span></span><br><span class="line">bye hello too</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>Note that the command here is “echo bye” and the additional arguments are “hello too”, making the command “echo bye hello too”, which outputs “bye hello too”.</p><p>Please note that xargs on UNIX makes an optimization where it will feed more than argument to the command at a time. We don’t expect you to make this optimization. To make xargs on UNIX behave the way we want it to for this lab, please run it with the -n option set to 1. For instance</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="built_in">echo</span> line</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p><strong>Hints</strong></p><ul><li>Use <code>fork</code> and <code>exec</code> to invoke the command on each line of input. Use <code>wait</code> in the parent to wait for the child to complete the command.</li><li>To read individual lines of input, read a character at a time until a newline (‘\n’) appears.</li><li>kernel/param.h declares MAXARG, which may be useful if you need to declare an argv array.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGLEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static char exe_path[DIRSIZ+2]=&quot;./&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* Argv[MAXARG];</span><br><span class="line"><span class="comment">// static char buffer[MAXARG*MAXARGLEN]=&quot;&quot;;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> tmp[MAXARGLEN];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* p;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint32 Argc,init_argc;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Debug</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>** argv = (<span class="type">char</span>**)Argv;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Argc;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXARG;++i)&#123;</span><br><span class="line">        Argv[i]=<span class="built_in">malloc</span>(MAXARGLEN);</span><br><span class="line">        <span class="built_in">memset</span>(Argv[i],<span class="number">0</span>,MAXARGLEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=init_argc;i&lt;Argc;++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(Argv[i],<span class="number">0</span>,MAXARGLEN);</span><br><span class="line">    &#125;</span><br><span class="line">    Argc=init_argc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Exec</span><span class="params">()</span>&#123;</span><br><span class="line">    Debug();</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        exec(Argv[<span class="number">0</span>],Argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait((<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Doubt life!!!</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* argv[<span class="number">4</span>]=&#123;<span class="string">&quot;grep&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;./a/b&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        exec(argv[<span class="number">0</span>],argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> wait((<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="comment">// test();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Xargs: too few arguments\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Init();</span><br><span class="line"></span><br><span class="line">    init_argc = argc - <span class="number">1</span>;</span><br><span class="line">    Argc=init_argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,argc);</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;argc;++i) printf(&quot;%s\n&quot;,argv[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;argc;++i)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(Argv[i<span class="number">-1</span>],argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,MAXARGLEN);</span><br><span class="line">    p = &amp;tmp[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>,&amp;ch,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;,ch);</span></span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            *p++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;tmp: %s\n&quot;,tmp);</span></span><br><span class="line">            <span class="built_in">strcpy</span>(Argv[Argc],tmp);</span><br><span class="line">            <span class="built_in">memset</span>(tmp,<span class="number">0</span>,MAXARGLEN);</span><br><span class="line">            p = &amp;tmp[<span class="number">0</span>];</span><br><span class="line">            Argc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// strcpy(exe_path+2,argv[1]);</span></span><br><span class="line">            <span class="comment">// strcpy(Argv[0],argv[0]);</span></span><br><span class="line">            <span class="comment">// printf(&quot;%s\n&quot;,exe_path);</span></span><br><span class="line">            <span class="comment">// printf(&quot;%s\n&quot;,Argv[0]);</span></span><br><span class="line">            <span class="comment">// Exec();</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Important!!!</span></span><br><span class="line">            <span class="type">char</span>* argvs[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Argc;++i) argvs[i]=Argv[i];</span><br><span class="line">            <span class="comment">// must use NULL to mark the end of the argv</span></span><br><span class="line">            argvs[Argc]=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">                exec(Argv[<span class="number">0</span>],argvs);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                wait((<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            *p++ = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h2><p>运行 <code>make grade</code>来评分</p><img src="/2023/03/07/MITOS-Lab01/image-20230307125645642.png" class title="This is an example image"><h2 id="Harvest-and-Reflections"><a href="#Harvest-and-Reflections" class="headerlink" title="Harvest and Reflections"></a>Harvest and Reflections</h2><ul><li><p>一些需要注意的点以及踩坑的地方都在代码里有注释</p></li><li><p>特别需要注意，对于管道通信，在<code>fork()</code>后，parent process一定要close：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以及传递参数时，最后一个参数，即<code>argv[argc]</code>一定要设置为<code>NULL</code>，否则可能根本调用不了</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MITOS—Lab01—Xv6-and-Unix-utilities&quot;&gt;&lt;a href=&quot;#MITOS—Lab01—Xv6-and-Unix-utilities&quot; class=&quot;headerlink&quot; title=&quot;MITOS—Lab01—Xv6 and Unix utilities&quot;&gt;&lt;/a&gt;MITOS—Lab01—Xv6 and Unix utilities&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码参考链接：&lt;a href=&quot;https://github.com/ChenYuHengSJTU/MIT_OSLab&quot;&gt;ChenYuHengSJTU/MIT_OSLab (github.com)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MITOS" scheme="https://chenyuhengsjtu.github.io/categories/MITOS/"/>
    
    
    <category term="Lab" scheme="https://chenyuhengsjtu.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>MITOS_Lab00</title>
    <link href="https://chenyuhengsjtu.github.io/2023/03/07/MITOS-Lab00/"/>
    <id>https://chenyuhengsjtu.github.io/2023/03/07/MITOS-Lab00/</id>
    <published>2023-03-07T03:48:58.000Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谨以此贴，记录环境搭建过程中被Ubuntu22-04坑惨的经历…一定要用Ubuntu20-04，否则在编译Qemu时会有一个神奇的包找不到发布源"><a href="#谨以此贴，记录环境搭建过程中被Ubuntu22-04坑惨的经历…一定要用Ubuntu20-04，否则在编译Qemu时会有一个神奇的包找不到发布源" class="headerlink" title="谨以此贴，记录环境搭建过程中被Ubuntu22.04坑惨的经历…一定要用Ubuntu20.04，否则在编译Qemu时会有一个神奇的包找不到发布源"></a>谨以此贴，记录环境搭建过程中被Ubuntu22.04坑惨的经历…一定要用Ubuntu20.04，否则在编译Qemu时会有一个神奇的包找不到发布源</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;谨以此贴，记录环境搭建过程中被Ubuntu22-04坑惨的经历…一定要用Ubuntu20-04，否则在编译Qemu时会有一个神奇的包找不到发布源&quot;&gt;&lt;a href=&quot;#谨以此贴，记录环境搭建过程中被Ubuntu22-04坑惨的经历…一定要用Ubuntu20-04，</summary>
      
    
    
    
    <category term="MITOS" scheme="https://chenyuhengsjtu.github.io/categories/MITOS/"/>
    
    
    <category term="Lab" scheme="https://chenyuhengsjtu.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP_AttackLab</title>
    <link href="https://chenyuhengsjtu.github.io/2023/03/01/CSAPP-AttackLab/"/>
    <id>https://chenyuhengsjtu.github.io/2023/03/01/CSAPP-AttackLab/</id>
    <published>2023-03-01T11:52:18.000Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Attacklab"><a href="#CSAPP-Attacklab" class="headerlink" title="CSAPP Attacklab"></a>CSAPP Attacklab</h1><p><strong>代码参考:<a href="https://github.com/ChenYuHengSJTU/CSAPP_Labs/tree/main/target1">CSAPP_Labs/target1 at main · ChenYuHengSJTU/CSAPP_Labs (github.com)</a></strong></p><span id="more"></span><h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><ul><li>实验Writeup的附录中有很多有用的东西，包括书写简单的汇编代码，将汇编编译为字节码，然后在反汇编得到汇编指令的字节表示。</li><li>使用 <code>objdump -d ctarget &gt; ctarget.txt</code>将ctarget反汇编</li></ul><h2 id="Part-I-Code-Injection-Attacks"><a href="#Part-I-Code-Injection-Attacks" class="headerlink" title="Part I: Code Injection Attacks"></a>Part I: Code Injection Attacks</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><ul><li><p>根据writeup的提示，需要利用getbuf中字符数组无边界检查的特性，将touch1的地址塞进栈中，让getbuf从栈中弹出地址时，弹出的是touch1的地址</p></li><li><p>上汇编代码</p><img src="/2023/03/01/CSAPP-AttackLab/image-20230301200029288.png" class title="This is an example image"></li><li><p>可以得到touch1地址：<code>0x4017c0</code></p></li><li><p>由汇编代码，getbuf将读入的字符串存放在栈中，预设的字符串最大长度为 <code>0x20 = 40 bytes</code>！！！</p></li><li><p>所以我们需要输入至少长度为48bytes的字符串，其中，41 - 48的子串为touch1的地址</p></li><li><p>得到答案：</p><img src="/2023/03/01/CSAPP-AttackLab/image-20230301200620547.png" class title="This is an example image"><img src="/2023/03/01/CSAPP-AttackLab/image-20230301200735291.png" class title="This is an example image"></li></ul><h3 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h3><ul><li><p>需要跳转到touch2，并且需要正确传递cookie为参数</p></li><li><p>根据x86的函数调用规则，应该把cookie传给rdi</p></li><li><p>所以需要自己插入一些代码</p></li><li><p>思路就是，让buf溢出，将返回地址设置为自己插入的代码的地址，在自己的代码中进行参数传递，然后再跳转到touch2</p></li><li><p>汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5561dcbc, %rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">retq</span><br></pre></td></tr></table></figure></li><li><p><code>gcc -c *.s -o *.0 objdump -d *.o &gt; *.d</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level3.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 c7 c7 bc dc 61 55 mov    $0x5561dcbc,%rdi</span><br><span class="line">   7:68 fa 18 40 00       pushq  $0x4018fa</span><br><span class="line">   c:c3                   retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>注意，需要考虑插入的字节序列的方向，其实在这里就从头往后依次插入就可以了，不需要调整方向</p></li><li><p>One possible solution：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 a8 dc 61 55 00 00 00 00 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 </span><br></pre></td></tr></table></figure><img src="/2023/03/01/CSAPP-AttackLab/image-20230305134244080.png" class title="This is an example image"></li></ul><h3 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h3><ul><li><p>同样需要传递参数，只不过这次传递的是一个字符串，所以还需要考虑把字符串放在内存的哪个位置</p></li><li><p>其实可以放在buf溢出的位置（我这里一次就成功了，不过看网上的其他答案，好像这个字符串必须放在内存位置较高的地方，否则有可能被touch3里面的函数调用覆盖，我直接放在了<code>buf + 8 + injected code length</code>的位置</p></li><li><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5561dcbc, %rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">retq</span><br></pre></td></tr></table></figure></li><li><p>反汇编后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">level3.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 c7 c7 bc dc 61 55 mov    $0x5561dcbc,%rdi</span><br><span class="line">   7:68 fa 18 40 00       pushq  $0x4018fa</span><br><span class="line">   c:c3                   retq   </span><br></pre></td></tr></table></figure></li><li><p>One possible solution：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 a8 dc 61 55 00 00 00 00 48 c7 c7 b6 dc 61 55 68 fa 18 40 00 c3 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><img src="/2023/03/01/CSAPP-AttackLab/image-20230305134834990.png" class title="This is an example image"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CSAPP-Attacklab&quot;&gt;&lt;a href=&quot;#CSAPP-Attacklab&quot; class=&quot;headerlink&quot; title=&quot;CSAPP Attacklab&quot;&gt;&lt;/a&gt;CSAPP Attacklab&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码参考:&lt;a href=&quot;https://github.com/ChenYuHengSJTU/CSAPP_Labs/tree/main/target1&quot;&gt;CSAPP_Labs/target1 at main · ChenYuHengSJTU/CSAPP_Labs (github.com)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CSAPP" scheme="https://chenyuhengsjtu.github.io/categories/CSAPP/"/>
    
    
    <category term="Lab" scheme="https://chenyuhengsjtu.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP_Bomblab</title>
    <link href="https://chenyuhengsjtu.github.io/2023/02/27/CSAPP-Bomblab/"/>
    <id>https://chenyuhengsjtu.github.io/2023/02/27/CSAPP-Bomblab/</id>
    <published>2023-02-27T06:59:26.000Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Bomblab"><a href="#CSAPP-Bomblab" class="headerlink" title="CSAPP Bomblab"></a>CSAPP Bomblab</h1><p><strong>代码参考：<a href="https://github.com/ChenYuHengSJTU/CSAPP_Labs/tree/main/bomblab/bomb">CSAPP_Labs/bomblab/bomb at main · ChenYuHengSJTU/CSAPP_Labs (github.com)</a></strong></p><span id="more"></span><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><ul><li>从README.md中，可知，我们可以创建一个answer.txt文件放置输出，这样就可以使用./bomb answer.txt来运行bomb，无需多次输入</li><li>使用 <code>gdb bomb</code> 启动调试</li><li>进入gdb界面后，输入 <code>run answer.txt</code> 运行</li><li>拆解第一个炸弹，进入gdb调试界面后加入断点 <code>b phase_1</code>,拆解后面的炸弹以此类推</li><li></li></ul><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1:"></a>Phase_1:</h3><ul><li><p>启动gdb后设置断点，然后 <code>c</code>运行至断点</p></li><li><p>在answer.txt中输入 <code>hello</code> 作为假设的输入</p></li><li><p>gdb中输入 <code>layout asm</code> 显示汇编代码</p></li><li><p><code>si</code> 单步运行（进入调用的函数）</p></li><li><p>首先进入函数 <code>string_not_equal</code></p><img src="/2023/02/27/CSAPP-Bomblab/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230227152842.png" class title="This is an example image"></li><li><p>打印寄存器 <code>p $rdi</code> ,发现是我们的输入，再打印另外一个传给string_not_equal的参数，<code>p $rsi</code>,即得到答案 <code>Border relations with Canada have never been better</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301125437522.png" class title="This is an example image"></li></ul><h3 id="Phase-2："><a href="#Phase-2：" class="headerlink" title="Phase_2："></a>Phase_2：</h3><ul><li><p>还是侥幸地输入 <code>hello</code>，然而还是炸了</p></li><li><p>打断点，然后调出tui的汇编界面</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301125814766.png" class title="This is an example image"></li><li><p>可以看到，<code>read_six_numbers</code>的函数调用</p></li><li><p>输入<code>1 2 3 4 5 6</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301130228780.png" class title="This is an example image"></li><li><p>接着向下看汇编，可以看到，这是一个循环，依次对输入的六个数进行一定的操作</p></li><li><p>其中最重要的应该是<code>add %eax，%eax</code>,将每次读入的数乘2，然后与下一个数比较</p></li><li><p>于是，我们的输入应该是一个公比为2的等比数列</p></li><li><p>我的输入：<code>1 2 4 8 16 32</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301130448413.png" class title="This is an example image"></li></ul><h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3:"></a>Phase_3:</h3><ul><li><p>我们依旧侥幸地输入<code>hello</code></p></li><li><p>炸！</p></li><li><p>看了一眼phase_3的汇编代码，第一眼并没有看到一些很有用的信息，于是从头开始单步执行 <code>si 或 ni</code></p></li><li><p>走到输入的函数调用<code>__isoc99 sscanfaplt</code></p></li><li><p>那么，传入的参数是什么呢</p></li><li><p>打印$edi <code>p (char*)$esi</code></p></li><li><p>！</p></li><li><p>发现新大陆，是C语言里极其常见的格式字符串<code>&quot;%d %d&quot;</code></p></li><li><p>应该传入两个参数</p></li><li><p>继续发扬优良传统，输入0,1</p></li><li><p>炸！</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301130448413.png" class title="This is an example image"></li><li><p>在这里（上图），我们发现，程序将两个参数<code>*(int*)$rsp</code>,<code>*(int*)($rsp+0xc)</code>依次与<code>$eax</code>比较，我们打印栈上的内容，发现是我们的输入！</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301131749091.png" class title="This is an example image"></li><li><p>再依次查看赋给<code>$eax</code>的值，可得答案：<code>1 311</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301131628096.png" class title="This is an example image"></li></ul><h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4:"></a>Phase_4:</h3><ul><li><p><code>hello</code>!!!</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301131847726.png" class title="This is an example image"></li><li><p>查看汇编，我们发现，phase_4调用了函数func4</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301131932909.png" class title="This is an example image"></li><li><p>至于接下去嘛，试着试着，就过了，看汇编，好像就是输入 <code>0 1</code></p></li><li><p>我的输入：<code>0 1</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301132222457.png" class title="This is an example image"></li></ul><h3 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5:"></a>Phase_5:</h3><ul><li><p><del>孤单的黑夜途中，只要输入<code>hello</code>,bomb就不会惶恐</del></p></li><li><p>查看汇编，<code>string_length</code>，嗷，还是输入字符串</p></li><li><p>不过这次有意思得多</p></li><li><p>phase_5的汇编代码很长，跳来跳去，还随时接一句<code>callq 0x40143a&lt;explode_bomb&gt;</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301132627539.png" class title="This is an example image"></li><li><p>我们发现有一个常量地址，<code>0x4024b0</code>，我们打印之，发现！！！</p></li><li><p><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?!</code></p></li><li><p><del>我的回答是 ctrl-c 不行，但是hello可以</del></p></li><li><p>不过这个字符串要怎么利用呢</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301132958157.png" class title="This is an example image"></li><li><p>一阵<code>ni</code>，发现代码一直在这段汇编之间跳，然后处理完后调用<code>string_not_equal</code></p></li><li><p><code>layout regs</code>,方便查看寄存器的变化，我们发现，这个过程是，使用 <code>0xf</code>依次对我们输入的每个字符的ascii码取低位，得到的值作为索引，到<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?!</code>中取字符，来生成比较的字符串</p></li><li><p>通过打印参数传递寄存器，得到被比较的字符串是<code>flyers</code></p></li><li><p>然后仔细比较、取字符、拼接</p></li><li><p>我的输入 <code>ionefg</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301133610376.png" class title="This is an example image"></li></ul><h3 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6:"></a>Phase_6:</h3><ul><li><p><del><code>hello</code></del></p></li><li><p>不能皮了，phase_6的代码还是<del>又臭又长</del>很难懂的</p></li><li><p>不过做到phase_6了，不难看出输入还是六个数</p></li><li><p>难道是？？？</p></li><li><p><code>1 2 3 4 5 6</code></p></li><li><p>bomb!</p></li><li><p>并且 — </p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301134005955.png" class title="This is an example image"></li><li><p>由这里的循环，发现，这六个数必须在1和6之间，且不能相等</p></li><li><p>呦吼，我们的输入到此刚好符合要求</p></li><li><p>往下看</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301134239734.png" class title="This is an example image"></li><li><p>发现这里也有一个常量地址 <code>$0x6032d0</code></p></li><li><p>迫不及待地打印之 <code>p *(int*)0x6032d0</code></p></li><li><p>发现是332</p></li><li><p>咦，奇怪的数！</p></li><li><p>往后打印，<code>p *(int*)(0x6032d0 + 8)</code></p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301134631553.png" class title="This is an example image"></li><li><p>这或许是？结构体？因为 <code>p *(int*)(0x6032d0 + 8)</code>的结果恰是 <code>0x6032d0 + 16</code>，而指针长度恰好是8 bytes，像不像链表？</p></li><li><p>一顿打印猛如虎</p></li><li><p>得到 <code>332,1 -&gt; 168,2 -&gt; 924,3 -&gt; 691,4 -&gt; 477,5 -&gt; 443,6</code></p></li><li><p>不过虽然发现至此，我们的答案还是被炸了</p></li><li><p>直接看最后！</p><img src="/2023/02/27/CSAPP-Bomblab/image-20230301135006162.png" class title="This is an example image"></li><li><p>我们发现，这个循环只有当最后的链表，从头到尾的数值依次增大才可以安全退出</p></li><li><p>我们打印这时候的链表，可以得到结论，phase_6是按照我们输入的1 - 6的序列来对链表进行排序的，我们输入<code>1 2 3 4 5 6</code>，得到的是逆序链表，类似于翻转链表</p></li><li><p>根据此规律，得到答案</p></li><li><p>我的输入：<code>4 3 2 1 6 5</code></p></li></ul><img src="/2023/02/27/CSAPP-Bomblab/image-20230301135307405.png" class title="This is an example image">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CSAPP-Bomblab&quot;&gt;&lt;a href=&quot;#CSAPP-Bomblab&quot; class=&quot;headerlink&quot; title=&quot;CSAPP Bomblab&quot;&gt;&lt;/a&gt;CSAPP Bomblab&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码参考：&lt;a href=&quot;https://github.com/ChenYuHengSJTU/CSAPP_Labs/tree/main/bomblab/bomb&quot;&gt;CSAPP_Labs/bomblab/bomb at main · ChenYuHengSJTU/CSAPP_Labs (github.com)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CSAPP" scheme="https://chenyuhengsjtu.github.io/categories/CSAPP/"/>
    
    
    <category term="Lab" scheme="https://chenyuhengsjtu.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP_DataLab</title>
    <link href="https://chenyuhengsjtu.github.io/2023/02/20/CSAPP-DataLab/"/>
    <id>https://chenyuhengsjtu.github.io/2023/02/20/CSAPP-DataLab/</id>
    <published>2023-02-20T11:42:22.000Z</published>
    <updated>2023-05-15T05:34:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-Datalab"><a href="#CSAPP-Datalab" class="headerlink" title="CSAPP Datalab"></a>CSAPP Datalab</h1><p><strong>注意可以使用的op以及op的总个数限制</strong></p><p><strong>代码参考：<a href="https://github.com/ChenYuHengSJTU/CSAPP_Labs/tree/main/datalab/datalab-handout">CSAPP_Labs/datalab/datalab-handout at main · ChenYuHengSJTU/CSAPP_Labs (github.com)</a></strong></p><span id="more"></span><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><ul><li>仅使用~和&amp;来实现按位异或</li><li>想法来源：离散数学真值表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m = (~x) &amp; y;</span><br><span class="line">  <span class="type">int</span> n = (~y) &amp; x;</span><br><span class="line">  <span class="keyword">return</span> ~((~m) &amp;  (~n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><ul><li>返回Tmin</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// easy</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><ul><li>这题着实把我整崩溃了</li><li>其实想法并不难，从Tmax的特性入手即可</li><li>0x7fffffff左移1位（即x*2 = x + x ）后加2就是0，当然需要排除-1（0xffffffff）的情况，即!!(x+1)即可</li><li>但是在处理的过程中，发现给我的答错了</li><li>百思不得其解</li><li>后来使用gdb考察汇编，发现整个isTmax函数只有三行汇编，而且汇编的返回值一定是0</li><li>解决方法：把makefile中的-Og的优化选项去掉，这样编译器才会乖乖算出(x + x +2)的值,否则就会优化掉</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x + x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!y) &amp; (!!(x + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><ul><li>不断配合使用 &lt;&lt; 和 | ，来构造出0xaaaaaaaa，x &amp; 0xaaaaaaaa后，如果确为allOddbits，应该等于0xaaaaaaaa，在加上 -0xaaaaaaaa （~0xaaaaaaaa+1），判断是否为0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// even-numbered bits can also be 1</span></span><br><span class="line">  <span class="type">int</span> mask1 = <span class="number">0xaa</span>;</span><br><span class="line">  <span class="type">int</span> mask2 = mask1 &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> mask3 = mask2 &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> mask4 = mask3 &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> mask = (mask1 | mask2 | mask3 | mask4);</span><br><span class="line">  <span class="comment">// x &amp; mask clears the impact of even-numbered 1s</span></span><br><span class="line">  <span class="comment">// to judge whether it equals to 0xaaaaaaaa</span></span><br><span class="line">  <span class="keyword">return</span> !((x &amp; mask) + (~mask) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><ul><li>在树状数组中习得</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// easy</span></span><br><span class="line">  <span class="keyword">return</span> (~x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><ul><li>第一种方法超出的最多运算符数限制</li><li>第二种方法是取出最低位，然后先判断0x30中的3，再分两种情况讨论最低四位，详见注释</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// my first method run out of all the 15 available ops</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int mask1 = 0xff;</span></span><br><span class="line">  <span class="comment">// int mask2 = mask1 &lt;&lt; 8;</span></span><br><span class="line">  <span class="comment">// int mask3 = mask2 &lt;&lt; 8;</span></span><br><span class="line">  <span class="comment">// int mask4 = mask3 &lt;&lt; 8;</span></span><br><span class="line">  <span class="comment">// int mask = (0xc0 | mask2 | mask3 | mask4);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int c = (x &amp; mask); </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int xx = x &amp; 0x3f;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int c1 = !(((xx + (~0x30) +1) &gt;&gt; 31) &amp; (0x1)); // == 0</span></span><br><span class="line">  <span class="comment">// int c2 = !((((~xx) + 1 + 0x39) &gt;&gt; 31) &amp; (0x1)); // == 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return (!c) &amp; (c1 &amp; c2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// first step is to fetch the low four bits</span></span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0xf</span>;</span><br><span class="line">  <span class="type">int</span> low = mask &amp; x;</span><br><span class="line">  <span class="comment">// then judge the upper 28 bits;use ^ to judge whether it equals to 0x30</span></span><br><span class="line">  <span class="type">int</span> xx = x + (~low) +<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> c = xx ^ <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// two cases of the low four bits</span></span><br><span class="line">  <span class="comment">// 0xxx or 1000 or 1001</span></span><br><span class="line">  <span class="type">int</span> mid = low &amp; <span class="number">0x6</span>;</span><br><span class="line">  <span class="type">int</span> high = low &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (!c) &amp; ((!high) | (!mid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><ul><li>需要一个小trick：!!x将x转换为0或1</li><li>还有就是，得到0或1后，怎么转换为0xffffffff，因为我们要用0xffffffff &amp; y或0xffffffff &amp; z来得到y和z。</li><li>还是利用0,1,-1之间的位级关系</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="comment">// use ! to judge , to change odinary nums to 0 or 1</span></span><br><span class="line">  <span class="comment">// after we get 0 or 1</span></span><br><span class="line">  <span class="comment">// for 0 : we can use !x to change it to 1 , then ~x + 1 to get -1 , with</span></span><br><span class="line">  <span class="comment">// all bits of 1</span></span><br><span class="line">  <span class="comment">// for 1 : we can use !!x to change it back to 1, then ~x+1 to get -1</span></span><br><span class="line">  <span class="keyword">return</span> ((~(!(!x)) + <span class="number">1</span>) &amp; y) | ((~(!x) + <span class="number">1</span>) &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><ul><li>判等：^</li><li>基本想法就是作差判断符号</li><li>但是需要考虑溢出，仅需考虑正数减负数的溢出</li><li>使用符号位判断溢出的特殊情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// use ^ to judge equalance</span></span><br><span class="line">  <span class="comment">// to avoid overflow , use the most significant bit to deal with different cases</span></span><br><span class="line">  <span class="type">int</span> xs = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> ys = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (!(x ^ y)) | (xs &amp; (!ys)) | ((!(xs ^ ys)) &amp; (x + (~y) +<span class="number">1</span>) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><ul><li>实现逻辑非</li><li>把数值分为三类：positive，negative，zero</li><li>取x与-x的符号位，在进行&amp;0x1（因为对负数实行逻辑右移）+ 1，得到xs与negxs</li><li>对于非零值，两者一定有一者为0</li><li>对于零，两者均为1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// we divide all x into three groups: 0,positive,negative</span></span><br><span class="line">  <span class="comment">// for negative and positive,one and only one of the significant bit of x and -x will be 1</span></span><br><span class="line">  <span class="comment">// but for 0,they are all 0</span></span><br><span class="line">  <span class="comment">// so we add 1 ,keep the trait for positive and negative numbers,but change the case of 0</span></span><br><span class="line">  <span class="comment">// last,for non-zero : xs == 0 &amp;&amp; negxs == 1 || xs == 1 &amp;&amp; negxs == 0</span></span><br><span class="line">  <span class="comment">// for zero : xs == 1 || negxs == 1 </span></span><br><span class="line">  <span class="type">int</span> xs = (((x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>) + <span class="number">1</span>) &amp; <span class="number">0x1</span> ;</span><br><span class="line">  <span class="type">int</span> negxs = (((((~x) + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>) + <span class="number">1</span>) &amp; <span class="number">0x1</span> ;</span><br><span class="line">  <span class="keyword">return</span> xs &amp; negxs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><ul><li>kind of hard</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> isZero = !x;</span><br><span class="line">  <span class="type">int</span> mask = ((!!x) &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> flag = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  x = ((~flag) &amp; x) | (flag &amp; (~x));</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit_16, bit_8, bit_4, bit_2, bit_1, bit_0;</span><br><span class="line"></span><br><span class="line">  bit_16 = (!((!!(x &gt;&gt; <span class="number">16</span>)) ^ <span class="number">0x1</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x &gt;&gt;= bit_16;</span><br><span class="line"></span><br><span class="line">  bit_8 = (!((!!(x &gt;&gt; <span class="number">8</span>)) ^ <span class="number">0x1</span>)) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= bit_8;</span><br><span class="line"></span><br><span class="line">  bit_4 = (!((!!(x &gt;&gt; <span class="number">4</span>)) ^ <span class="number">0x1</span>)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= bit_4;</span><br><span class="line"></span><br><span class="line">  bit_2 = (!((!!(x &gt;&gt; <span class="number">2</span>)) ^ <span class="number">0x1</span>)) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= bit_2;</span><br><span class="line"></span><br><span class="line">  bit_1 = (!((!!(x &gt;&gt; <span class="number">1</span>)) ^ <span class="number">0x1</span>));</span><br><span class="line">  x &gt;&gt;= bit_1;</span><br><span class="line"></span><br><span class="line">  bit_0 = x;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (isZero | (mask &amp; res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><ul><li>浮点数的三道题均不难，更多的是考察对于IEEE754浮点数标准的理解记忆</li><li>第一题，分情况（规格化，非规格化，NAN）讨论即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> expmask = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> fmask1 = <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">int</span> fmask2 = fmask1 &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> fmask3 = fmask2 &lt;&lt; <span class="number">7</span>;</span><br><span class="line">  <span class="type">int</span> fmask = fmask1 | fmask2 | fmask3;</span><br><span class="line">  <span class="type">int</span> frac = uf &amp; fmask;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &amp; expmask) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &amp;&amp; (<span class="built_in">exp</span> - <span class="number">0xff</span>))</span><br><span class="line">    <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">exp</span>)</span><br><span class="line">    frac = frac &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  uf = (s &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | (frac);</span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><ul><li>也是只需分情况讨论即可，注意exp位域的最大值为1111110，不能是1111111</li><li>从这道题中可以get到，对于溢出，均处理为inf，而不是NAN</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> expmask = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &amp; expmask) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> fmask1 = <span class="number">0xff</span>;</span><br><span class="line">  <span class="type">int</span> fmask2 = fmask1 &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> fmask3 = fmask2 &lt;&lt; <span class="number">7</span>;</span><br><span class="line">  <span class="type">int</span> fmask = fmask1 | fmask2 | fmask3;</span><br><span class="line">  <span class="type">int</span> frac = uf &amp; fmask;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> M;</span><br><span class="line">  <span class="type">int</span> E;</span><br><span class="line">  <span class="type">int</span> bias = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0xff</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &amp;&amp; (<span class="built_in">exp</span> - <span class="number">0xff</span>))&#123;</span><br><span class="line">    M = <span class="number">1</span> &lt;&lt; <span class="number">23</span> | frac;</span><br><span class="line">    E = <span class="built_in">exp</span> - bias;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    M = frac;</span><br><span class="line">    E = <span class="number">1</span> - bias;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res;</span><br><span class="line">  <span class="keyword">if</span>(E &gt; <span class="number">23</span>)&#123;</span><br><span class="line">    res = M &lt;&lt; E;</span><br><span class="line">    <span class="comment">// do not forget this anything out of range</span></span><br><span class="line">    <span class="keyword">if</span>(E &gt;= <span class="number">8</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(E == <span class="number">23</span>) res = M;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> e = <span class="number">23</span> - E;</span><br><span class="line">    <span class="keyword">if</span>(e &gt;= <span class="number">24</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    res = M &gt;&gt; (<span class="number">23</span> - E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(s) <span class="keyword">return</span> -res;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><ul><li>特别注意float的表示范围，是不对称的，既要考虑规格化，也要考虑非规格化</li><li>具体细节可以看书</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span>;</span><br><span class="line">  <span class="type">int</span> frac;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(x &gt;= <span class="number">128</span>)&#123;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">0xff</span>;</span><br><span class="line">    frac = <span class="number">0</span>;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">-126</span> - <span class="number">23</span>)&#123;</span><br><span class="line">    frac = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= <span class="number">-126</span> - <span class="number">23</span> &amp;&amp; x &lt;= <span class="number">-127</span>)&#123;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    frac = <span class="number">1</span> &lt;&lt; (x - (<span class="number">-126</span> - <span class="number">23</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    frac = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">127</span> + x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res = (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | (frac) | (s &lt;&lt; <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><p><code>./run.sh</code></p><img src="/2023/02/20/CSAPP-DataLab/image-20230313133456674.png" class title="This is an example image">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CSAPP-Datalab&quot;&gt;&lt;a href=&quot;#CSAPP-Datalab&quot; class=&quot;headerlink&quot; title=&quot;CSAPP Datalab&quot;&gt;&lt;/a&gt;CSAPP Datalab&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意可以使用的op以及op的总个数限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码参考：&lt;a href=&quot;https://github.com/ChenYuHengSJTU/CSAPP_Labs/tree/main/datalab/datalab-handout&quot;&gt;CSAPP_Labs/datalab/datalab-handout at main · ChenYuHengSJTU/CSAPP_Labs (github.com)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CSAPP" scheme="https://chenyuhengsjtu.github.io/categories/CSAPP/"/>
    
    
    <category term="Lab" scheme="https://chenyuhengsjtu.github.io/tags/Lab/"/>
    
  </entry>
  
</feed>
